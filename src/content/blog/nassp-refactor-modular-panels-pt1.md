---
title: 'NASSP Refactoring - Modular Panel System, Part 1'
description: "Or: \"Let's try not to hard-code everything this time\""
pubDatetime: 2024-11-05
ogImage: '@assets/images/nassp-refactor-modular-panels-pt1/thumb.png'
tags: 
    - nassp
    - programming
    - space
    - Project Apollo
draft: true
---

This has been at the forefront of my mind lately when thinking about potential improvements for NASSP's core functionality. To establish a crucial definition first, a "panel" in the context of NASSP and Orbiter is a data structure representing a viewable region within the vessel. This panel is displayed to the pilot and rendered on top of the 3D scene the vessel is currently located within (such as flying through space or on a celestial body). A vessel typically has one or more panels to represent various locations or "viewpoints" within a vessel's cockpit or cabin area. They often contain dynamic elements like switches, gauges, computer displays, and other controls, all of which are used for interacting with the vessel and receiving information about the status of various systems. These panels can be 2D images or mapped to a 3D model dubbed the "virtual cockpit" or "VC".

Within our code is a library called "PanelSDK" which is a bit of a misnomer. It was added into our project from what is now a long-gone Orbiter addon site, archived [here](https://web.archive.org/web/20051017194639/http://217.10.196.198:80/Orbiter/main.html). Originally, it was intended to be used to allow for both modular panel components to be displayed to the user as well as modular subsystems that drove the various displays, gauges, etc. However, while NASSP makes extensive use of the modular systems functionality of this library (which I will inevitably have to make a post about refactoring), all of the panel-related functionality [was removed about a year ago](https://github.com/orbiternassp/NASSP/commit/ed16e1f0614af56eb780ff066ff97131931ecd66), since it appears to have gone unused for the lifespan of the project. Instead, most—if not all—of our panel code involves hard-coded... everything. Pointers to gauges and switches are stored directly in the vessel classes, and the routines associated with refreshing the state of gauges/components and drawing them to the screen are monstrous switch/case blocks relying on long strings of `#define` statements to declare the internal codenames of every individual component or object on the panel that must be drawn or processed. Rather than reverting the change that removed the modular panel code from PanelSDK and trying to begin using it, I feel it would be more appropriate to create a new, modern system that fits NASSP's needs. While there's something to be said about not reinventing the wheel, a lot of the PanelSDK code is archaic and makes heavy use of pointer math and manually allocated buffers for its parsing and processing logic. This might have been necessary at the time of its creation in the mid-2000s, but such practices can be avoided these days thanks to improvements in the C++ standard library. Not only do we have smart pointers and safer methods of dealing with text parsing, but we also have efficient data structures provided by the STL which will let us use a more appropriate collection than the singly-linked lists that PanelSDK loves so much.

So, what exactly might a from-scratch modular panel system look like? Here's a simplified dragram that illustrates a possible "information flow" for how we would define the panels to be used for our vessels and how that data would be subsequently built at runtime into something the user can see and interact with:

![Flow diagram of how the panels might be "built"](@assets/images/nassp-refactor-modular-panels-pt1/flow-diagram.png)

So, with that general design in mind, the next path I travelled down was: what format to use for our config files? The existing PanelSDK systems code parses its own custom config syntax which vaguely resembles XML. However the parsing code for that, as previously mentioned, is rife with pointer math and other obtuse logic that is no longer well-understood or easy to scale. Even so, designing a *new* custom format would be rather silly when there are countless formats already designed and that have stable parsers for C++. My first thought was JSON, but while it is extremely mature and well-supported, its syntax can be a bit cumbersome to read in a text editor or make manual changes to. Not to mention, it's likely more complex than our needs require. So, [TOML (Tom's Obvious Markup Language)](https://toml.io/en/) seemed like a decent fit. There appears to be a [rather mature parsing library](https://marzer.github.io/tomlplusplus/) designed for modern C++ versions which was also GPL-compatible and featured a single-include header-only version that means no extra work necessary to integrate it into our project. Here's a basic example of what a panel config file would look like:

![Example TOML-based panel config file for the Lunar Module](@assets/images/nassp-refactor-modular-panels-pt1/basic-config.png)

