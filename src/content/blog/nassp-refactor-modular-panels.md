---
title: 'NASSP Refactoring - Modular Panel System'
description: "Or: \"Let's try not to hard-code everything this time\""
pubDate: 'Sep 21, 2024'
heroImage: '/CustomSite101/img/blog/nassp-refactor-cmake/thumb.png'
---

This one's currently just theoretical in nature, but nevertheless it's been in the forefront of my mind lately when thinking about potential improvements for NASSP's core functionality. To establish a crucial definition first, a "panel" in the context of NASSP and Orbiter is an area representing a viewable region within the vessel, displayed to the pilot and rendered over the 3D scene the vessel is currently located within (such as flying through space or on a celestial body). A vessel typically has one or more panels to represent various locations or "viewpoints" within a vessel's cockpit or cabin area. They often contain dynamic elements like switches, gauges, computer displays, and other controls, all of which are used for interacting with the vessel and receiving information about the status of various systems. These panels can be 2D images or mapped to a 3D model dubbed the "virtual cockpit" or "VC". Within our code is a library called "PanelSDK" which is a bit of a misnomer. Originally, it *was* intended to be used to allow for both modular panel components to be displayed to the user as well as modular subsystems that drove the various displays, gauges, etc. However, while NASSP makes extensive use of the modular systems functionality of this library (which I will inevitably have to make a post about refactoring), all of the panel-related functionality [was removed about a year ago](https://github.com/orbiternassp/NASSP/commit/ed16e1f0614af56eb780ff066ff97131931ecd66), since it appears to have sat unused for the lifespan of the project. Instead, most—if not all—of our panel code involves hard-coded... everything. Pointers to gauges and switches are stored directly in the vessel classes, and the routines associated with refreshing the state of gauges/components and drawing them to the screen are monstrous switch/case blocks relying on long strings of `#define` statements to declare the internal codenames of every individual component or object on the panel that must be drawn or processed. Rather than reverting the change that removed the modular panel code from PanelSDK and trying to begin using it, I feel it would be more appropriate to create a new, modern system that fits NASSP's needs. While there's something to be said about not reinventing the wheel, a lot of the PanelSDK code is archaic and makes heavy use of pointer math and manually allocated buffers. This might have been necessary at the time of its creation, but such practices are to be avoided these days, and can be thanks to improvements in the C++ standard library. Not only do we have smart pointers and safer methods of dealing with text parsing, but we also have efficient data structures provided by the STL which will let us use a more appropriate collection than a singly-linked list.

So, what exactly might a from-scratch modular panel system look like? Here's a simplified dragram that illustrates a possible "information flow" for how we would define the panels to be used for our vessels and how that data would be subsequently built at runtime into something the user can see and interact with:

![Successful compilation of the CMake branch](/CustomSite101/img/blog/nassp-refactor-modular-panels/flow_diagram.png)

