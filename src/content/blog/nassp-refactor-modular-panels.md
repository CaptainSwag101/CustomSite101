---
title: 'NASSP Refactoring - Modular Panel System'
description: "Or: \"Let's try not to hard-code everything this time\""
pubDate: 'Sep 21, 2024'
heroImage: '/CustomSite101/img/blog/nassp-refactor-cmake/thumb.png'
---

This one's currently just theoretical in nature, but nevertheless it's been in the forefront of my mind lately when thinking about potential improvements for NASSP's core functionality. To establish a crucial definition first, a "panel" in the context of NASSP and Orbiter is the visual area displayed to the pilot. These panels can be 2D images or mapped to a 3D model dubbed the "virtual cockpit" or "VC". Within our code is a library called "PanelSDK" which is a bit of a misnomer. Originally, it *was* intended to be used to allow for both modular panel components to be displayed to the user as well as modular subsystems that drove the various displays, gauges, etc. However, most if not all of the panel-related functionality [was removed about a year ago](https://github.com/orbiternassp/NASSP/commit/ed16e1f0614af56eb780ff066ff97131931ecd66), since it appears to have sat unused for the lifespan of the project. Instead, most if not all of our panel code involves hard-coded... everything. Pointers to gauges and switches are stored directly in the vessel classes, and the routines associated with refreshing the systems and drawing them to the screen are monstrous switch/case blocks relying on long strings of `#define` statements to declare the internal codenames of every individual component or object on the panel that must be drawn or processed. Rather than try reverting the change that removed the modular panel code from PanelSDK, I feel it would be more appropriate to try creating a new, modern system that fits NASSP's needs. While there's something to be said about not reinventing the wheel, a lot of the PanelSDK code is archaic and makes heavy use of pointer math. This might have been necessary at the time of its creation, but such practices are to be avoided these days, and can be thanks to improvements in the C++ standard library. Not only do we have smart pointers and safer methods of dealing with text parsing, but we also have efficient data structures provided by the STL which will let us use a more appropriate collection than a singly-linked list.

![Successful compilation of the CMake branch](/CustomSite101/img/blog/nassp-refactor-modular-panels/flow_diagram.png)

